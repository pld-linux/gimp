--- gimp-1.1.29/plug-ins/perl/Gimp/Lib.xs.wiget	Mon Oct 30 02:34:17 2000
+++ gimp-1.1.29/plug-ins/perl/Gimp/Lib.xs	Sat Nov 25 03:38:54 2000
@@ -18,9 +18,11 @@
 #if HAVE_PDL
 #define PDL_clean_namespace
 #include <pdlcore.h>
+#if 0
 #undef croak
 #define croak Perl_croak
 #endif
+#endif
 
 /* various functions allocate static buffers, STILL.  */
 #define MAX_STRING 4096
@@ -94,7 +96,7 @@
       /* Get pointer to structure of core shared C routines */
       CoreSV = perl_get_sv("PDL::SHARE", FALSE);
       if (!CoreSV)
-        croak("gimp-perl-pixel functions require the PDL::Core module, which was not found");
+        Perl_croak(aTHX_ "gimp-perl-pixel functions require the PDL::Core module, which was not found");
 
       PDL = (Core*) SvIV(CoreSV);
     }
@@ -123,13 +125,13 @@
   PDL->converttype (p, PDL_B, PDL_PERM);
 
   if ((*p)->ndims < ndims + (dim0 > 1))
-    croak (__("dimension mismatch, pdl has dimension %d but at least %d dimensions required"), (*p)->ndims, ndims + (dim0 > 1));
+    Perl_croak (aTHX_ __("dimension mismatch, pdl has dimension %d but at least %d dimensions required"), (*p)->ndims, ndims + (dim0 > 1));
 
   if ((*p)->ndims > ndims + 1)
-    croak (__("dimension mismatch, pdl has dimension %d but at most %d dimensions allowed"), (*p)->ndims, ndims + 1);
+    Perl_croak (aTHX_ __("dimension mismatch, pdl has dimension %d but at most %d dimensions allowed"), (*p)->ndims, ndims + 1);
 
   if ((*p)->ndims > ndims && (*p)->dims[0] != dim0)
-    croak (__("pixel size mismatch, pdl has %d channel pixels but %d channels are required"), (*p)->dims[0], dim0);
+    Perl_croak (aTHX_ __("pixel size mismatch, pdl has %d channel pixels but %d channels are required"), (*p)->dims[0], dim0);
 }
 
 static void pixel_rgn_pdl_delete_data (pdl *p, int param)
@@ -221,7 +223,7 @@
        GimpDrawable *gdr = gimp_drawable_get (id);
 
        if (!gdr)
-         croak (__("unable to convert Gimp::Drawable into Gimp::GimpDrawable (id %d)"), id);
+         Perl_croak (aTHX_ __("unable to convert Gimp::Drawable into Gimp::GimpDrawable (id %d)"), id);
 
        if (!stash)
          stash = gv_stashpv (PKG_GDRAWABLE, 1);
@@ -239,7 +241,7 @@
 static GimpDrawable *old_gdrawable (SV *sv)
 {
   if (!(sv_derived_from (sv, PKG_GDRAWABLE)))
-    croak (__("argument is not of type %s"), PKG_GDRAWABLE);
+    Perl_croak (aTHX_ __("argument is not of type %s"), PKG_GDRAWABLE);
 
   /* the next line lacks any type of checking.  */
   return (GimpDrawable *)SvIV(SvRV(sv));
@@ -262,7 +264,7 @@
 static GimpTile *old_tile (SV *sv)
 {
   if (!sv_derived_from (sv, PKG_TILE))
-    croak (__("argument is not of type %s"), PKG_TILE);
+    Perl_croak (aTHX_ __("argument is not of type %s"), PKG_TILE);
   
   /* the next line lacks any type of checking.  */
   return (GimpTile *)SvIV(*(hv_fetch ((HV*)SvRV(sv), "_tile", 5, 0)));
@@ -291,7 +293,7 @@
           || sv_derived_from (drawable, PKG_CHANNEL))
         drawable = sv_2mortal (new_gdrawable (SvIV (SvRV (drawable))));
       else
-        croak (__("argument is not of type %s"), PKG_GDRAWABLE);
+        Perl_croak (aTHX_ __("argument is not of type %s"), PKG_GDRAWABLE);
     }
 
   return drawable;
@@ -318,7 +320,7 @@
 static GimpPixelRgn *old_pixelrgn (SV *sv)
 {
   if (!sv_derived_from (sv, PKG_PIXELRGN))
-    croak (__("argument is not of type %s"), PKG_PIXELRGN);
+    Perl_croak (aTHX_ __("argument is not of type %s"), PKG_PIXELRGN);
   
   return (GimpPixelRgn *)SvPV_nolen(SvRV(sv));
 }
@@ -588,7 +590,7 @@
 	          count += 1 + !!is_array (SvIV (type));
 	      }
 	    else
-	      croak (__("malformed paramdef, expected [PARAM_TYPE,\"NAME\",\"DESCRIPTION\"] or PARAM_TYPE"));
+	      Perl_croak (aTHX_ __("malformed paramdef, expected [PARAM_TYPE,\"NAME\",\"DESCRIPTION\"] or PARAM_TYPE"));
 	  }
 	
 	if (def)
@@ -656,7 +658,7 @@
     sv = sv_bless (newRV_noinc (sv), stash);
 
   if (stash && !SvOBJECT(SvRV(sv)))
-    croak ("jupp\n");
+    Perl_croak (aTHX_ "jupp\n");
   
   return sv;
 }
@@ -695,7 +697,7 @@
    r = unbless (sv, type, croak_str);
 
    if (croak_str [0])
-      croak (croak_str);
+      Perl_croak (aTHX_ croak_str);
    
    return r;
 }
@@ -713,7 +715,7 @@
   PUTBACK;
   
   if (perl_call_pv ("Gimp::canonicalize_colour", G_SCALAR) != 1)
-    croak (__("FATAL: canonicalize_colour did not return a value!"));
+    Perl_croak (aTHX_ __("FATAL: canonicalize_colour did not return a value!"));
   
   SPAGAIN;
   
@@ -886,7 +888,7 @@
       case GIMP_PDB_STRINGARRAY:	push_gimp_av (arg, d_stringarray, neuSVpv, array_as_ref); break;
 	
       default:
-	croak (__("dunno how to return param type %d"), arg->type);
+	Perl_croak (aTHX_ __("dunno how to return param type %d"), arg->type);
     }
   
   if (sv)
@@ -1342,10 +1344,10 @@
 		              argc++;
 		          }
 		        else
-		          croak ("internal error (please report): too many arguments to main");
+		          Perl_croak (aTHX_ "internal error (please report): too many arguments to main");
 		      }
 		    else
-		      croak (__("arguments to main not yet supported!"));
+		      Perl_croak (aTHX_ __("arguments to main not yet supported!"));
 		    
 	            gimp_is_initialized = 1;
 		    RETVAL = gimp_main (argc, argv);
@@ -1403,7 +1405,7 @@
 		GimpParamDef *return_vals;
 
                 if (!gimp_is_initialized)
-                  croak ("_gimp_procedure_available(%s) called without an active connection", proc_name);
+                  Perl_croak (aTHX_ "_gimp_procedure_available(%s) called without an active connection", proc_name);
 		
 		if (gimp_procedural_db_proc_info (proc_name, &proc_blurb, &proc_help, &proc_author,
 		    &proc_copyright, &proc_date, &proc_type, &nparams, &nreturn_vals,
@@ -1445,7 +1447,7 @@
 		GimpParamDef *return_vals;
 		
                 if (!gimp_is_initialized)
-                  croak ("gimp_procedural_db_proc_info called without an active connection");
+                  Perl_croak (aTHX_ "gimp_procedural_db_proc_info called without an active connection");
 
 		if (gimp_procedural_db_proc_info (proc_name, &proc_blurb, &proc_help, &proc_author,
 		    &proc_copyright, &proc_date, &proc_type, &nparams, &nreturn_vals,
@@ -1487,7 +1489,7 @@
                 int i=0, j=0; /* work around bogus warning.  */
 
                 if (!gimp_is_initialized)
-                  croak ("gimp_call_procedure(%s,...) called without an active connection", proc_name);
+                  Perl_croak (aTHX_ "gimp_call_procedure(%s,...) called without an active connection", proc_name);
 
 		if (trace)
 		  trace_init ();
@@ -1609,10 +1611,10 @@
                     
 		
                     if (croak_str[0])
-                      croak (croak_str);
+                      Perl_croak (aTHX_ croak_str);
                   }
                 else
-                  croak (__("gimp procedure '%s' not found"), proc_name);
+                  Perl_croak (aTHX_ __("gimp procedure '%s' not found"), proc_name);
 	}
 
 void
@@ -1655,7 +1657,7 @@
             g_free (apd);
           }
         else
-          croak (__("params and return_vals must be array refs (even if empty)!"));
+          Perl_croak (aTHX_ __("params and return_vals must be array refs (even if empty)!"));
 
 void
 gimp_uninstall_temp_proc(name)
@@ -1803,7 +1805,7 @@
         else if (items == 3)
 	  RETVAL = gimp_pixel_rgns_register (3, old_pixelrgn (ST (0)), old_pixelrgn (ST (1)), old_pixelrgn (ST (2)));
         else
-          croak (__("gimp_pixel_rgns_register supports only 1, 2 or 3 arguments, upgrade to gimp-1.1 and report this error"));
+          Perl_croak (aTHX_ __("gimp_pixel_rgns_register supports only 1, 2 or 3 arguments, upgrade to gimp-1.1 and report this error"));
         OUTPUT:
         RETVAL
 
@@ -2144,7 +2146,7 @@
             stride = pr->bpp * newdata->dims[newdata->ndims-2];
 
             if ((int)pr->h != newdata->dims[newdata->ndims-1])
-              croak (__("pdl height != region height"));
+              Perl_croak (aTHX_ __("pdl height != region height"));
 
             for (y   = 0, src = newdata->data, dst = pr->data;
                  y < (int)pr->h;
@@ -2184,7 +2186,7 @@
 	GimpTile *	tile
 	CODE:
         need_pdl ();
-        croak (__("gimp_tile_get_data is not yet implemented\n"));
+        Perl_croak (aTHX_ __("gimp_tile_get_data is not yet implemented\n"));
 	gimp_tile_ref (tile);
 	gimp_tile_unref (tile, 0);
 	OUTPUT:
@@ -2195,7 +2197,7 @@
 	GimpTile *	tile
 	SV *	data
 	CODE:
-        croak (__("gimp_tile_set_data is not yet implemented\n")); /*(void *)data;*/
+        Perl_croak (aTHX_ __("gimp_tile_set_data is not yet implemented\n")); /*(void *)data;*/
 	gimp_tile_ref_zero (tile);
 	gimp_tile_unref (tile, 1);
 
@@ -2217,7 +2219,7 @@
           gimp_tile_get_data		= 11
           gimp_tile_set_data		= 12
 	CODE:
-        croak (__("This module was built without support for PDL."));
+        Perl_croak (aTHX_ __("This module was built without support for PDL."));
  
 #endif
 
--- gimp-1.1.29/plug-ins/perl/Net/Net.xs.wiget	Sat Nov 25 03:55:51 2000
+++ gimp-1.1.29/plug-ins/perl/Net/Net.xs	Sat Nov 25 03:57:42 2000
@@ -26,8 +26,10 @@
 #if HAVE_PDL
 
 # include <pdlcore.h>
+#if 0
 # undef croak
 # define croak Perl_croak
+#endif
 
 #if 0
 /* hack, undocumented, argh! */
@@ -71,10 +73,10 @@
           hv_delete (object_cache, (char *)&id, sizeof(id), G_DISCARD);
         }
       else
-        croak ("Internal error: Gimp::Net #101, please report!");
+        Perl_croak (aTHX_ "Internal error: Gimp::Net #101, please report!");
     }
   else
-    croak ("Internal error: Gimp::Net #100, please report!");
+    Perl_croak (aTHX_ "Internal error: Gimp::Net #100, please report!");
 }
 
 /* allocate this much as initial length */
@@ -135,7 +137,7 @@
       else if (SvTYPE(rv) == SVt_PVMG)
         sv2net (deobjectify, s, rv);
       else
-        croak ("Internal error: unable to convert reference in sv2net, please report!");
+        Perl_croak (aTHX_ "Internal error: unable to convert reference in sv2net, please report!");
     }
   else if (SvOK(sv))
     {
@@ -190,7 +192,7 @@
       case 'b':
         sscanf (s, "%x:%n", &ui, &n); s += n;
         if (ui >= sizeof str)
-          croak ("Internal error: stashname too long, please report!");
+          Perl_croak (aTHX_ "Internal error: stashname too long, please report!");
 
         memcpy (str, s, ui); s += ui;
         str[ui] = 0;
@@ -204,7 +206,7 @@
 
             cv = hv_fetch (object_cache, (char *)(id=l,&id), sizeof(id), 0);
             if (!cv)
-              croak ("Internal error: asked to deobjectify an object not in the cache, please report!");
+              Perl_croak (aTHX_ "Internal error: asked to deobjectify an object not in the cache, please report!");
 
             sv = *cv;
             SvREFCNT_inc (sv);
@@ -225,7 +227,7 @@
         break;
 
       default:
-        croak ("Internal error: unable to handle argtype '%c' in net2sv, please report!", s[-1]);
+        Perl_croak (aTHX_ "Internal error: unable to handle argtype '%c' in net2sv, please report!", s[-1]);
     }
 
   *_s = s;
